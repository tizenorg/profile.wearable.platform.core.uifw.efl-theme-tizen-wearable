/*
 * Copyright (c) 2015 Samsung Electronics Co., Ltd All Rights Reserved
 *
 * BSD 2-Clause License (http://www.opensource.org/licenses/bsd-license.php)
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *   1. Redistributions of source code must retain the above copyright notice, this
 *      list of conditions and the following disclaimer.
 *   2. Redistributions in binary form must reproduce the above copyright notice,
 *      this list of conditions and the following disclaimer in the documentation
 *      and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#define SLIDE_SPEED_WEIGHT 0.5
#define SLIDE_TEXT_GAP 60
#define SLIDE_TEXT_CHAR_GAP "<align=left><font_size=16>            </font_size></align>"    //12 spaces
#define SLIDE_TEXT_MAX_LENGTH (2*(1024+6))

styles {
   style { name: "textblock_style";
      base: "font=Tizen:style=Condensed font_size="LABEL_FONT_SIZE_INC" color=#ffffffff text_class=label";
      tag:  "hilight" "+ font_weight=Bold";
   }
}

group { name: "elm/label/base/default";
   parts {
      part {
         name: "label.text.clip";
         type: RECT;
         description {
            state: "default" 0.0;
         }
      }
      part {
         name: "elm.text";
         type: TEXTBLOCK;
         scale: 1;
         clip_to: "label.text.clip";
         description {
            state: "default" 0.0;
            text {
               style: "textblock_style";
               min: 0 1;
               align: 0.0 0.0;
            }
         }
      }
   }
}

group { name: "elm/label/base/slide_roll";
   script {
      public g_duration = 0;
      public g_stopslide = 0;
      public g_timer_id = 0;
      public g_anim_id = 0;
      public g_tb_w = 0;
      public g_tb_h = LABEL_FONT_SIZE_INC;
      public org_text = 0;
      public message(Msg_Type:type, id, ...) {
         if (type == MSG_FLOAT_SET) {
            new Float:duration;
            duration = getfarg(2);
               if (id == 0)
                  set_float(g_duration, duration);
               else
                  set_float(g_duration, duration / get_int(g_tb_h) * SLIDE_SPEED_WEIGHT);
         }
      }
      public get_tb_width() {
         new x, y, w, h;
         set_state(PART:"elm.text", "no_ellipsis", 0.0);
         get_geometry(PART:"elm.text", x, y, w, h);
         set_int(g_tb_w, w);
         set_int(g_tb_h, h);
         set_state(PART:"text_clip", "default", 0.0);
         get_geometry(PART:"text_clip", x, y, w, h);
         set_int(org_text, w);
      }
      public slide_to_end_anim(val, Float:pos) {
         if (get_int(g_stopslide)) return;
         set_tween_state(PART:"elm.text.slide", pos*0.5, "slide_begin", 0.0, "slide_end", 0.0);
         if (pos >= 1.0) {
            stop_slide();
            emit("elm,state,slide,end", "");
            set_int(g_timer_id, timer(1.5, "start_slide", 0));
         }
      }
      public slide_to_end() {
         if (get_int(g_stopslide)) return;
         set_int(g_anim_id, anim(get_float(g_duration), "slide_to_end_anim", 0));
      }
      public start_slide(val) {
         new buf[1024];
         new buffer[SLIDE_TEXT_MAX_LENGTH];
         new Float:len;
         set_int(g_stopslide, 0);
         get_tb_width();
         if (!get_float(g_duration)) {
            len = get_int(g_tb_w) + SLIDE_TEXT_GAP;
            set_float(g_duration, len / get_int(g_tb_h) * SLIDE_SPEED_WEIGHT);
         }
         if (get_int(g_tb_w) > get_int(org_text)) {
            get_text(PART:"elm.text", buf, 1024);
            snprintf(buffer, SLIDE_TEXT_MAX_LENGTH, "%s", buf);
            strcat(buffer, SLIDE_TEXT_CHAR_GAP);
            strcat(buffer, buf);
            strcat(buffer, SLIDE_TEXT_CHAR_GAP);
            set_text(PART:"elm.text.slide", buffer);

            set_state(PART:"elm.text.slide", "slide_begin", 0.0);
            set_state(PART:"text_clip", "hide", 0.0);
            set_state(PART:"slide_text_clip", "show", 0.0);
            slide_to_end();
         }
         else
         {
            emit("elm,state,no,sliding", "");
         }
      }
      public stop_slide() {
         new slide_start_timer;
         new slide_anim_id;
         set_int(g_stopslide, 1);
         set_float(g_duration, 0);
         slide_start_timer = get_int(g_timer_id);
         if (slide_start_timer) {
            cancel_timer(slide_start_timer);
            set_int(g_timer_id, 0);
         }
         slide_anim_id = get_int(g_anim_id);
         if (slide_anim_id) {
            cancel_anim(slide_anim_id);
            set_int(g_anim_id, 0);
         }
         set_text(PART:"elm.text.slide", "");
         set_state(PART:"elm.text", "default", 0.0);
         set_state(PART:"elm.text.slide", "default", 0.0);
         set_state(PART:"text_clip", "default", 0.0);
         set_state(PART:"slide_text_clip", "default", 0.0);
      }
   }
   parts {
      part { name: "label.text.clip";
         type: RECT;
         description { state: "default" 0.0;
         }
      }
      part { name: "text_clip";
         type: RECT;
         mouse_events: 0;
         clip_to: "label.text.clip";
         description { state: "default" 0.0;
         }
         description { state: "hide" 0.0;
            inherit: "default" 0.0;
            visible: 0;
         }
      }
      part { name: "elm.text";
         type: TEXTBLOCK;
         scale: 1;
         clip_to: "text_clip";
         description { state: "default" 0.0;
            align: 0.0 0.5;
            text {
               style: "textblock_style";
               min: 1 1;
            }
         }
         description { state: "no_ellipsis" 0.0;
            inherit: "default" 0.0;
            text.min: 1 1;
         }
      }
      part { name: "slide_text_clip";
         type: RECT;
         mouse_events: 0;
         clip_to: "label.text.clip";
         description { state: "default" 0.0;
            visible: 0;
         }
         description { state: "show" 0.0;
            inherit: "default" 0.0;
            visible: 1;
         }
      }
      part { name: "slide_text_gap";
         type: SPACER;
         scale: 1;
         description { state: "default" 0.0;
            fixed: 1 0;
            min: SLIDE_TEXT_GAP 0;
            max: SLIDE_TEXT_GAP -1;
            align: 1.0 0.5;
            rel1.relative: 0.0 0.0;
            rel2.relative: 0.0 1.0;
         }
      }
      part { name: "elm.text.slide";
         type: TEXTBLOCK;
         scale: 1;
         clip_to: "slide_text_clip";
         description { state: "default" 0.0;
            align: 0.0 0.5;
            text {
               style: "textblock_style";
               min: 1 1;
            }
         }
         description { state: "slide_begin" 0.0;
            inherit: "default" 0.0;
            text.min: 1 1;
            rel1.relative: 0.0 0.0;
            rel2.relative: 0.0 1.0;
         }
         description { state: "slide_end" 0.0;
            inherit: "default" 0.0;
            align: 1.0 0.5;
            text.min: 1 1;
            text.align: 1.0 0.5;
            rel1 { relative: 0.0 0.0; to: "slide_text_gap"; }
            rel2 { relative: 1.0 1.0; to: "slide_text_gap"; }
         }
      }
   }
   programs {
      program { name: "start_slide";
         source: "elm";
         signal: "elm,state,slide,start";
         script {
            run_program(PROGRAM:"stop_slide");
            set_int(g_timer_id, timer(1.5, "start_slide", 0));
         }
      }
      program { name: "stop_slide";
         source: "elm";
         signal: "elm,state,slide,stop";
         script {
            stop_slide();
         }
      }
   }
}



